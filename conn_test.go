// conn_test.go
//
// Copyright (C) 2022 Holger de Carne
//
// This software may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.

package nsdp

import (
	"encoding/hex"
	"log"
	"net"
	"testing"

	"github.com/stretchr/testify/require"
)

const connTestTarget string = IPv4BroadcastTarget

//const connTestTarget string = "127.0.0.1:63322"

func TestConnSendReceiveMessageBroadcast(t *testing.T) {
	server, err := startTestServer(connTestTarget)
	require.Nil(t, err)
	server.addResponses(
		"0102000000000000bcd07432b8dc6cb0ce1c839400003c994e534450000000000001000847533130384576330003000773776974636831000400066cb0ce1c839400050000000600040a01000300070004ffff0000000800040a010001000b000100000d0007322e30362e3137000e0000000f0001010c0000030105000c0000030200000c0000030304000c0000030400000c0000030504000c0000030600000c0000030700000c00000308000010000031010000000117a01268000000000b6110b700000000000000000000000000000000000000000000000000000000000000001000003102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000310300000000023285f70000000004e04786000000000000000000000000000000000000000000000000000000000000000010000031040000000000133f340000000000cf6d030000000000000000000000000000000000000000000000000000000000000000100000310500000000091b5d1a0000000107d948cb0000000000000000000000000000000000000000000000000000000000000000100000310600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000031070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000003108000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffff0000",
		"0102000000000000bcd07432b8dce4f4c6ffa7a20000c1314e53445000000000000100084753313038457633000300077377697463683200040006e4f4c6ffa7a200050000000600040a01000400070004ffff0000000800040a010001000b000100000d0007322e30362e3137000e0000000f0001010c0000030105000c0000030205000c0000030302000c0000030405000c0000030500000c0000030600000c0000030700000c0000030800001000003101000000006cb52f9600000000081fca3f0000000000000000000000000000000000000000000000000000000000000000100000310200000000057a417d000000001c32d25e000000000000000000000000000000000000000000000000000000000000000010000031030000000003811cd000000000567839630000000000000000000000000000000000000000000000000000000000000000100000310400000000005415d000000000053ad52600000000000000000000000000000000000000000000000000000000000000001000003105000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000310600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000031070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000003108000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffff0000")
	conn, err := NewConn(connTestTarget, true)
	require.Nil(t, err)
	defer conn.Close()
	msg := prepareTestMessage()
	responses, err := conn.SendReceiveMessage(msg)
	require.Nil(t, err)
	require.Equal(t, 2, len(responses))
}

func TestConnSendReceiveMessageUnicast(t *testing.T) {
	server, err := startTestServer(connTestTarget)
	require.Nil(t, err)
	server.addResponses("0102000000000000bcd07432b8dce4f4c6ffa7a20000c5514e53445000000000000100084753313038457633000300077377697463683200040006e4f4c6ffa7a200050000000600040a01000400070004ffff0000000800040a010001000b000100000d0007322e30362e3137000e0000000f0001010c0000030105000c0000030205000c0000030302000c0000030405000c0000030500000c0000030600000c0000030700000c0000030800001000003101000000006cb5350900000000081fccc70000000000000000000000000000000000000000000000000000000000000000100000310200000000057a417d000000001c32d890000000000000000000000000000000000000000000000000000000000000000010000031030000000003811cd00000000056783f950000000000000000000000000000000000000000000000000000000000000000100000310400000000005415d000000000053adb5800000000000000000000000000000000000000000000000000000000000000001000003105000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000310600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000031070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000003108000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffff0000")
	conn, err := NewConn(connTestTarget, true)
	require.Nil(t, err)
	defer conn.Close()
	msg := prepareTestMessage()
	msg.Header.DeviceAddress = []byte{0xe4, 0xf4, 0xc6, 0xff, 0xa7, 0xa2}
	responses, err := conn.SendReceiveMessage(msg)
	require.Nil(t, err)
	require.Equal(t, 1, len(responses))
}

func prepareTestMessage() *Message {
	message := NewMessage(ReadRequest)
	message.AppendTLV(EmptyDeviceModel())
	message.AppendTLV(EmptyDeviceName())
	message.AppendTLV(EmptyDeviceMAC())
	message.AppendTLV(EmptyDeviceLocation())
	message.AppendTLV(EmptyDeviceIP())
	message.AppendTLV(EmptyDeviceNetmask())
	message.AppendTLV(EmptyRouterIP())
	message.AppendTLV(EmptyDHCPMode())
	message.AppendTLV(EmptyPortStatus())
	message.AppendTLV(EmptyPortStatistic())
	message.AppendTLV(EmptyFWVersionSlot1())
	message.AppendTLV(EmptyFWVersionSlot2())
	message.AppendTLV(EmptyNextFWSlot())
	return message
}

type testServer struct {
	taddr          *net.UDPAddr
	responseChunks [][][]byte
}

func startTestServer(target string) (*testServer, error) {
	taddr, err := net.ResolveUDPAddr("udp", target)
	if err != nil {
		return nil, err
	}
	server := &testServer{
		taddr:          taddr,
		responseChunks: make([][][]byte, 0),
	}
	if server.taddr.IP.IsLoopback() {
		conn, err := net.ListenUDP("udp", server.taddr)
		if err != nil {
			return nil, err
		}
		go func() {
			defer conn.Close()
			buffer := make([]byte, 8192)
			for _, responseChunk := range server.responseChunks {
				log.Printf("TestServer Listening on %s", server.taddr)
				len, addr, err := conn.ReadFromUDP(buffer)
				if err != nil {
					log.Printf("TestServer Listening failure; cause: %v", err)
					break
				}
				log.Printf("TestServer %s < %s\n%s", server.taddr, addr, hex.EncodeToString(buffer[:len]))
				err = server.handleRequest(conn, addr, buffer[:len], responseChunk)
				if err != nil {
					log.Printf("TestServer Failed to handle message; cause: %v", err)
					break
				}
			}
		}()
	}
	return server, nil
}

func (server *testServer) addResponses(encodedResponses ...string) {
	responseChunk := make([][]byte, 0)
	for _, encodedResponse := range encodedResponses {
		response, err := hex.DecodeString(encodedResponse)
		if err != nil {
			log.Panicf("TestServer Invalid response; cause: %v", err)
		}
		responseChunk = append(responseChunk, response)
	}
	server.responseChunks = append(server.responseChunks, responseChunk)
}

func (server *testServer) handleRequest(conn *net.UDPConn, addr *net.UDPAddr, request []byte, responseChunk [][]byte) error {
	requestMsg, err := UnmarshalMessage(request)
	if err != nil {
		return err
	}
	for _, response := range responseChunk {
		responseMsg, err := UnmarshalMessage(response)
		if err != nil {
			return err
		}
		responseMsg.Header.HostAddress = requestMsg.Header.HostAddress
		responseMsg.Header.Sequence = requestMsg.Header.Sequence
		_, err = conn.WriteToUDP(responseMsg.Marshal(), addr)
		if err != nil {
			return err
		}
	}
	return nil
}
